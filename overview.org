# -*- mode: org -*-

#+OPTIONS: toc:nil
#+PROPERTY: mkdirp yes

* Actors

Within the ECi Order Placement system a dealer typically takes on the role of /Buyer/. A vendor or
supplier (typical readers of this document) take the role of /Seller/. A /Consumer/ is the buyer's
customer and in rare cases, the buyer. There are nuances to be discussed, we will not attempt to
explain right now rather we will take up the details for the specific use cases as we come across
them.

#+BEGIN_SRC plantuml :file ./images/buyer-usecases.puml.png :exports results
@startuml sequence-buyer2seller.png
Buyer -> (Place Order)
Buyer -> (Select Shipment Method)
Buyer -> (Stock, Cost, Date)
@enduml
#+END_SRC

#+BEGIN_SRC plantuml :file ./images/seller-usecases.puml.png :exports results
@startuml sequence-buyer2seller.png
Seller -> (Invoice Shipment)
Seller -> (Announce Shipment)
Seller -> (Accept Order)
Seller -> (Reject Order)
@enduml
#+END_SRC

#+BEGIN_SRC plantuml :file ./images/consumer-usecases.puml.png :exports results
@startuml sequence-buyer2seller.png
Consumer -> (TODO)
@enduml
#+END_SRC

* Endpoints

There are six endpoints, three provided by the Seller's system

#+BEGIN_SRC plantuml :file ./images/sequence-buyer2seller.puml.png :exports results
@startuml sequence-buyer2seller.png
Buyer -> Seller: [ POST ] stock
Buyer -> Seller: [ GET ] shipment methods
Buyer -> Seller: [ POST ] order
@enduml
#+END_SRC

And three provided by the Buyer's system:

#+BEGIN_SRC plantuml :file ./images/sequence-seller2buyer.puml.png :exports results
@startuml sequence-seller2buyer.png
Seller -> Buyer: [ POST ] order<U+0394> | error
Seller -> Buyer: [ POST ] shipment
Seller -> Buyer: [ POST ] invoice
@enduml
#+END_SRC

* Connecting

** HTTPS / TLS

The ECi Order Placement services will always connect using a minimum of TLS 1.2.

** Authentication

*** Buyer -> Seller

The Seller is responsible for providing participating dealers (Buyers) a user name
and password which the ECi system will use to connect to the Seller's system. This
information will be passed to the seller via HTTP Basic Authentication [[http://www.rfc-editor.org/info/rfc7617][RFC 7617]].
Stock and Order resources allow for additional non-schema defined information
(opaque) to be supplied by the Buyer and delivered to the Seller.

*** Seller -> Buyer
ECi is responsible for assigning and maintaining an ID and an API key to each of
the Seller systems. This information will be passed to the buyer system via HTTP
Basic Authentication. Stock and Order resources allow for additional non-schema
defined information (opaque) to be supplied by the Seller and delivered to the Buyer.

* Code / Reference Type

At the heart of the order placement 1.0 resource schema is the notion or concept of a code. A code
is intended to describe a thing of interest to both humans and software and has the following three
components:

- Code :: software facing identity function; used to identify the object to a software system
- Description :: human facing description providing more information than the name allows
- Name :: human facing identity function; use to identify the object to human readers

In version 1.5 and beyond the code type will be replaced with a reference type. The human facing
elements are left in place and has an additional ~remarks~ field. The software facing ~code~ has
been extended to allow us to identify a thing in many different systems.

- Codes :: an array of codes that identify the object in one or more software systems
- Description :: human facing description providing more information than the name allows
- Name :: human facing identity function; use to identify the object to human readers
- Remarks :: non-schema human facing information sent back and forth between buyer and seller

The array of ~codes~ will be be populated with one or more codes, where a code is defined as

- Code :: retains its definition above. the form changes but the concept remains i.e. software facing identity function; used to identify the object to one or more software systems
- Reference :: the actor system that 'owns' or the value.

A contrived example, under my fingers is a keyboard. Using the reference type we can describe the
keyboard from the viewpoint of different actor's actor systems:

- Codes :: [[ buyer : wbkbd2345 ] [ seller : kbdbt4cha ]]
- Description :: four channel bluetooth Apple layout full size aluminum keyboard with backlit keys
- Name :: wireless keyboard
- Remarks :: requires two AAA batteries

Or in other words, this keyboard is known as ~wbkbd2345~ in the buyer's system and as ~kbdbt4cha~
in the Seller's system.

Example XML

#+BEGIN_SRC xml
  <?xml version='1.0' encoding='utf-8'?>

  <Reference>
    <Codes>
      <Code><Code>wbkbd2345</Code><Reference>Buyer</Reference></Code>
      <Code><Code>kbdbt4cha</Code><Reference>Seller</Reference></Code>
    </Codes>
    <Name>wireless keyboard</Name>
    <Description>four channel bluetooth Apple layout full size aluminum keyboard with backlit keys</Description>
    <Remarks>requires two AAA batteries</Remarks>
  </Reference>
#+END_SRC

Example Schema

#+BEGIN_SRC xml :export none
  <xs:schema attributeFormDefault='unqualified'
             elementFormDefault='qualified'
             xmlns:xs='http://www.w3.org/2001/XMLSchema'>

    <xs:element name='Reference' type='ReferenceType'/>

    <xs:complexType name='ReferenceType'>
      <xs:sequence>
        <xs:element name='Codes'       type='CodesType' />
        <xs:element name='Name'        type='xs:string' />
        <xs:element name='Description' type='xs:string' />
        <xs:element name='Remarks'     type='xs:string' />
      </xs:sequence>
    </xs:complexType>

    <xs:complexType name='CodesType'>
      <xs:sequence minOccurs='1' maxOccurs='5000'>
        <xs:element name='Code' type='CodeType'/>
      </xs:sequence>
    </xs:complexType>

    <xs:complexType name='CodeType'>
      <xs:sequence>
        <xs:element name='Code'      type='xs:string' />
        <xs:element name='Reference' type='CodeRefType' />
      </xs:sequence>
    </xs:complexType>

    <xs:simpleType name='CodeRefType'>
      <xs:restriction base='xs:string'>
        <xs:enumeration value='Buyer'/>
        <xs:enumeration value='Consumer'/>
        <xs:enumeration value='Manufacturer'/>
        <xs:enumeration value='Seller'/>
      </xs:restriction>
    </xs:simpleType>
  </xs:schema>

#+END_SRC

* Errors

** Defition of Terms

- Code :: Software facing value that uniquely identifies the error. If ~Code~ is not populated ~Name~ MUST be populated
- Description :: Human facing text. Generally populated when there is a failure or warning of some type. If populated the value should give the human user some idea of where the failure or warning is happening and why it might be happening.
- Name :: Human facing value that uniquely identifies the probe. If ~Name~ is not populated ~Code~ MUST be populated
- Remarks :: Human facing text. Generally populated with one or more actions the user can take to solve the problem
- When :: The date and time of probe execution. If ~When~ is populated ~HttpStatusCode~ MUST also be populated

** Resource Schema

*** JSON

#+BEGIN_SRC xml :tangle ./rsrc-schema/src/vnd.eci.stg.error.1.5.0.xsd
    <?xml version='1.0' encoding='utf-8'?>

    <xs:schema xmlns:xs='http://www.w3.org/2001/XMLSchema'
               elementFormDefault='qualified'
               xml:lang='en'>

      <xs:element name='Items'>
        <xs:complexType>
          <xs:sequence minOccurs='1' maxOccurs='50'>
            <xs:element name='Error' type='ErrorType'/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:complexType name='ErrorType'>
        <xs:sequence>
          <xs:annotation>
            <xs:documentation>
              TODO
            </xs:documentation>
          </xs:annotation>
          <xs:element name='Code'        type='xs:string'   minOccurs='0' maxOccurs='1' />
          <xs:element name='Name'        type='xs:string'   minOccurs='0' maxOccurs='1' />
          <xs:element name='Description' type='xs:string'   minOccurs='0' maxOccurs='1' />
          <xs:element name='When'        type='xs:dateTime' minOccurs='0' maxOccurs='1' />
          <xs:element name='Remarks'     type='xs:string'   minOccurs='0' maxOccurs='1' />
        </xs:sequence>
      </xs:complexType>
    </xs:schema>
#+END_SRC

*** XML

#+BEGIN_SRC json :tangle ./rsrc-schema/src/vnd.eci.stg.error.1.5.0.json
  {
    "id": "./vnd.eci.stg.error.1.5.0.json",
    "$schema": "http://json-schema.org/draft-08/schema#",
    "title": "Error",
    "description": "defines when an error occurred, what the error was, and perhaps how to resolve it.",
    "type": "array",
    "Items": {
      "additionalProperties": false,
      "anyOf": [{"required": ["Code"]},
                {"required": ["Name"]},
                {"required": ["When"]}],

      "properties" : {

        "Code": {
          "description": "software facing value used to identify and respond to errors",
          "type": "string",
          "minLength": 1,
          "maxLength": 32
        },

        "Name": {
          "description": "human facing value used to identify and respond to errors",
          "type": "string",
          "minLength": 1,
          "maxLength": 32
        },

        "Description": {
          "description": "human readable string describing the error",
          "type": "string",
          "minLength": 1,
          "maxLength": 128
        },

        "When": {
          "description": "origination date and time of the error",
          "type" : "string",
          "format": "date-time"
        },

        "Remarks": {
          "description": "details of the error that may help users solve the problem",
          "type": "string",
          "minLength": 1,
          "maxLength" : 256
        }
      }
    }
  }
#+END_SRC

* Resource Types

These types are intended to represent data in flight and are not meant to represent data at rest.

There are six resource types exchanged between the Buyer's system and the Seller's system:

#+BEGIN_SRC dot cmdline: -Kdot -Tpng :file ./images/resource-types.dot.png
  digraph {
    stockD [ label="stock&Delta;" ]
    orderD [ label="order&Delta;" ]

    stock -> error;
    stock -> stockD;
    stockD -> order;
    shipment_method -> order;
    order -> error;
    order -> orderD;
    orderD -> shipment;
    orderD -> invoice;
  }
#+END_SRC

Not all Seller systems support resources or endpoints for Shipment Methods, Order\Delta
(accept/reject), or Shipment information. We have chosen to represent resources using
JSON Schema and prefer Seller implementations also choose a JSON representation. The
Buyer's system can be programmed to send and receive resources in other representations,
though this is not part of the standard agreement and will need to be addressed separately.
