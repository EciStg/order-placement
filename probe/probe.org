# -*- mode: org -*-

#+EXPORT_FILE_NAME: ./README.md
#+OPTIONS: toc:nil
#+PROPERTY: mkdirp yes
#+STARTUP: content

* Probe

#+BEGIN_SRC plantuml :file ../images/probe-class-diagram.puml.png :exports results
@startuml
hide circle

interface probe {
.. is-a code ..
{field} + code : string
{field} + description : string
{field} + name : string
{field} + remarks : string
.. is-an event ..
{field} + status : string
{field} + when : datetime
.. is-linkable ..
{field} + self : string
.. is/has-a collection ..
{field} + itemCount : int
{field} + items : [Probe]
}
@enduml
#+END_SRC

#+RESULTS:
[[file:../images/probe-class-diagram.puml.png]]

Client applications that do not send an Accept header or choose to accept the unversioned or
"untyped" content types should receive the latest version of the probe.

#+BEGIN_EXAMPLE
Accept: application/json
Accept: application/xml
Accept: application/vnd.eci.stg.probe.json
Accept: application/vnd.eci.stg.probe.xml
Accept: application/vnd.eci.stg.probe-1.5.0.json
Accept: application/vnd.eci.stg.probe-1.5.0.xml
#+END_EXAMPLE

** Test Results

#+BEGIN_SRC shell :exports both :results verbatim
  ajv -s ../rsrc-schema/src/vnd.eci.stg.probe.1.5.0.json -d "../rsrc-schema/tst/vnd.eci.stg.probe*.json" 2>&1
  xmllint --noout --schema ../rsrc-schema/src/vnd.eci.stg.probe.1.5.0.xsd ../rsrc-schema/tst/vnd.eci.stg.probe.1.5.0*.xml 2>&1
#+END_SRC

#+RESULTS:
: ../rsrc-schema/tst/vnd.eci.stg.probe.1.5.0-probe-bottom.json valid
: ../rsrc-schema/tst/vnd.eci.stg.probe.1.5.0-probes.json valid
: ../rsrc-schema/tst/vnd.eci.stg.probe.1.5.0-probe-bottom.xml validates
: ../rsrc-schema/tst/vnd.eci.stg.probe.1.5.0-probes.xml validates

** Overview

The purpose of a Probe is to allow ECi and Seller health monitoring systems and staff to detect
problems before customers do and provide actionable information, allowing problems to be identified
and corrected as quickly as possible. It is expected that QA, IT, and Support health monitoring
systems and staff will have access to these probes and will access them multiple times throughout
the day.

#+BEGIN_SRC plantuml :file ../images/probe-usecase-diagram.puml.png :exports results
@startuml sequence-probes.png
IT -> (Execute Custom Probe)
IT -> (List Custom Probes)
IT -> (Execute Bottom Probe)
IT -> (Execute Top Probe)
@enduml
#+END_SRC

** Discussion

#+BEGIN_SRC plantuml :file ../images/probe-sequence-diagram.puml.png :exports results
  @startuml sequence-probe.png
  group top probe
      IT -> Seller: GET **./probes/top**
      Seller -> IT: HttpStatusCode

  group bottom probe
      IT -> Seller: GET **./probes/bottom**
      Seller -> IT: vnd.eci.stg.probe-1.5.0

  group custom probes
    IT -> Seller: GET **./probes**
    Seller -> IT: vnd.eci.stg.probe-1.5.0
    IT -> Seller: GET ./probes/[custom]
@enduml
#+END_SRC

#+RESULTS:
[[file:../images/probe-sequence-diagram-top.puml.png]]

There are three well-defined probe routes for each service and any number of custom or special
purpose routes available. Discussion of the function of each route is found in the Use Cases
section of this document.

The three well-defined probe routes are:

#+BEGIN_EXAMPLE
./probes
./probes/top
./probes/bottom
#+END_EXAMPLE

Information returned from the probes that return a body may be cached by the client, the server, or
both. If implementors decide to cache on the server, please note that these probes are designed
to be accessed, via HTTP GET, several times per hour. The cache time needs to be balanced against
the purpose of the probes, which is to alert IT systems and staff of problems before customers and
customer support staff experience the problem. The means and length of time probe results can be cached
at the implementor's discretion. The date and time field in the probe resource, called ~When~,
will tell readers when the probe was last executed and, with a bit of simple math, how long the
results have been cached.

Custom probes will be executed on demand by IT, QA, and Support staff and should not be used by
frequent running software as they may strain the API and have a negative impact on users and
systems.

Implementors may instruct browsers and client applications to cache results for a certain period of
time, in this example 5 minutes, using HTTP/1.1 Cache-Control.

#+BEGIN_EXAMPLE
Cache-Control: public, max-age=300
#+END_EXAMPLE

Implementors may also include an HTTP/1.0 ~Expires~ header (not shown). To further decrease unwanted
volume or strain, implementors may wish protect probe routes by traditional DDOS mitigation measures,
including white listing.

** Definition of Terms

- code :: Software facing value that uniquely identifies the probe. If ~code~ is not populated, ~name~ must be.
- description :: Human facing text that describes the purpose of the probe and the purpose of the activity or function being probed.
- name :: Human facing value that uniquely identifies the probe. If ~name~ is not populated, ~description~ must be.
- remarks :: Human facing text, populated when there is a failure or warning. The text should give the human user some idea of where and why the failure or warning is occurring and what can be done to correct the problem.
- self :: URL identifying the probe that was executed. It is always required.
- status :: Human and Software facing value populated in the returned body of an HTTP GET for all probes except the top probe. Values in the *200s* are successful, values in the *500s* indicate something is wrong with the API. If ~status~ is populated, ~when~ must also be populated.
- when :: Date and time of probe execution. If ~when~ is populated, ~status~ must be.

** Use Cases

[[../images/probe-usecase-diagram.puml.png]]

*** Execute top probe ~./probes/top~

This probe must be a light weight and fast running indicator of API availability; think of it like
a *ping*. It must do as little as possible yet still be able to announce that the API is up and
running. It is expected this probe will be called one or more times per minute. Calling applications
are required to check the HTTP Status Code and interpret it as pass, *200 - 299*, or fail, *400 - 599*.
A body must not be returned to the caller.

**** Version 1.0

#+BEGIN_QUOTE
Not supported.
#+END_QUOTE

**** Version 1.5

#+BEGIN_QUOTE
Required for ECi implementations.

Recommended for Seller implementations.
#+END_QUOTE

Checking the HTTP Status Code for the top probe:

#+BEGIN_SRC shell :exports both
curl -sw "%{http_code}\\n" http://some-host/some-api/probes/top
#+END_SRC

**** Version 2.0

#+BEGIN_QUOTE
TBD
#+END_QUOTE

*** Execute bottom probe ~./probes/bottom~

The bottom probe should test all of the layers of the API or application and all vital connections
to other systems, APIs, databases, etc. IT, QA, and Support staff and their applications must be
able to execute this modest impact probe by an HTTP GET. This probe will be called several times per
hour by automated systems and on demand by staff.

Implementors are required to return a valid, meaningful HTTP Status Code.

Calling applications are required to check the HTTP Status Code. Calling applications are also
required to read and obey HTTP/1.1 Cache-Control headers.

A body is optional. When a body is provided, it must contain an array of one or more probe objects,
each of which will contain its own HTTP Status Code. If the array contains a single object, the HTTP
Status Code must match the value returned by the HTTP GET.

The bottom probe's ~code~ value must be ~bottom~.

**** Version 1.0

#+BEGIN_QUOTE
Not supported.
#+END_QUOTE

**** Version 1.5

#+BEGIN_QUOTE
Required for ECi implementations.

Recommended for Seller implementations.
#+END_QUOTE

***** JSON

#+BEGIN_SRC json :tangle ../rsrc-schema/tst/vnd.eci.stg.probe.1.5.0-probe-bottom.json
  {
    "code" :"bottom",
    "name": "Bottom Probe",
    "description":"Ensures the API can reach all of the systems, databases, files, and other resources required to operate normally.",
    "remarks":"The database cannot be contacted. Ensure the database is running and network reachable.",
    "self": "https://some-host/some-api/probes/bottom",
    "status": "500",
    "when": "2018-04-23T18:25:40.611Z"
  }
#+END_SRC

***** XML

#+BEGIN_SRC xml :tangle ../rsrc-schema/tst/vnd.eci.stg.probe.1.5.0-probe-bottom.xml
  <item>
    <code>bottom</code>
    <name>Bottom Probe</name>
    <description>The database cannot be contacted. Ensure the database is running and network reachable.</description>
    <remarks>The database cannot be contacted. Ensure the database is running and network reachable.</remarks>
    <self>https://some-host/some-api/probes/bottom</self>
    <status>500</status>
    <when>2018-04-23T18:25:40.611Z</when>
  </item>
#+END_SRC

**** Version 2.0

#+BEGIN_QUOTE
TBD
#+END_QUOTE

*** List custom probes ~./probes~

In addition to top and bottom probes, implementors may choose to support additional probes that can
provide useful information to QA, IT, and Support staff. The purpose of this route is to enumerate
all of the probes supported by the API, including top and bottom. With this probe, IT, QA, and Support
staff and their applications can expect a list of probes they can execute. Each probe provides a
unique URL, called ~self~. Users and applications will execute the probe by means of an HTTP GET.

Custom probes should be run on demand by staff and should not be routinely executed by automated
systems and applications.

**** Version 1.0

#+BEGIN_QUOTE
Not supported.
#+END_QUOTE

**** Version 1.5

#+BEGIN_QUOTE
Optional.
#+END_QUOTE

***** JSON

#+BEGIN_SRC json :tangle ../rsrc-schema/tst/vnd.eci.stg.probe.1.5.0-probes.json
  {
    "code": "probes",
    "self": "https://some-host/some-api/probes",
    "itemCount": 3,
    "items": [
      {
        "self": "https://some-host/some-api/probes/top",
        "code": "top",
        "name": "Top Probe"
      },
      {
        "self": "https://some-host/some-api/probes/bottom",
        "code" :"bottom",
        "name": "Bottom Probe",
        "description":"The database cannot be contacted. Ensure the database is running and network reachable."
      },
      {
        "self": "https://some-host/some-api/probes/auth",
        "code" :"auth"
      },
      {
        "self": "https://some-host/some-api/probes/con-db",
        "code": "con-db",
        "name": "database connection test"
      }
    ]
  }
#+END_SRC

***** XML

#+BEGIN_SRC xml :tangle ../rsrc-schema/tst/vnd.eci.stg.probe.1.5.0-probes.xml
    <item>
      <code>probes</code>
      <self>https://some-host/some-api/probes</self>
      <itemCount>3</itemCount>
      <items>
        <item>
          <code>top</code>
          <name>Top Item</name>
          <self>https://some-host/some-api/items/top</self>
        </item>
        <item>
          <code>bottom</code>
          <name>Bottom Item</name>
          <description>The database cannot be contacted. Ensure the database is running and network reachable.</description>
          <self>https://some-host/some-api/items/bottom</self>
        </item>
        <item>
          <code>auth</code>
          <self>https://some-host/some-api/items/auth</self>
        </item>
        <item>
          <code>db</code>
          <name>database connection test</name>
          <self>https://some-host/some-api/items/con-db</self>
        </item>
      </items>
    </item>
#+END_SRC

**** Version 2.0

#+BEGIN_QUOTE
TBD
#+END_QUOTE

** Resource Schema

*** Version 1.0

#+BEGIN_QUOTE
Not supported.
#+END_QUOTE

*** Version 1.5

**** JSON

#+BEGIN_SRC json :tangle ../rsrc-schema/src/vnd.eci.stg.probe.1.5.0.json
  {
    "id": "./vnd.eci.stg.probe.1.5.0.json",
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "Probe",
    "description": "Defines the location and description of a probe. Upon execution ( HTTP GET ) defines the state of the probe.",

    "type": "object",
    "additionalProperties": false,
    "required": ["self"],
    "anyOf": [{"required": ["code"]},
              {"required": ["name"]}],
    "dependencies": {
      "status": { "required": [ "when" ]},
      "when":  { "required": [ "status" ]}},

    "properties": {
      "code": {
        "description": "software facing value that uniquely identifies the probe",
        "type": "string",
        "minLength": 1,
        "maxLength": 32
      },

      "name": {
        "description": "human readable string describing the probe's purpose",
        "type": "string",
        "minLength": 1,
        "maxLength": 32
      },

      "description": {
        "description": "details from the probe that may help users understand the health of an endpoint",
        "type": "string",
        "minLength": 1,
        "maxLength" : 128
      },

      "remarks": {
        "description": "details of the error that may help users solve the problem",
        "type": "string",
        "minLength": 1,
        "maxLength" : 256
      },

      "self": {
        "description": "system function identifying a unique system owned resource as a URL",
        "type": "string",
        "minLength": 1,
        "maxLength": 1024
      },

      "status": {
        "description": "usually used bottom probe but may also be returned by api or application specific probes",
        "type": "string",
        "minLength": 1,
        "maxLength": 32
      },

      "when": {
        "description": "origination date and time of probe execution",
        "type" : "string",
        "format": "date-time"
      },

      "itemCount": {
        "description": "number of things in the items collection",
        "type" : "number",
        "minimum": 1,
        "maximum": 1000
      },

      "items": {
        "description": "one or more things a buyer wishes a seller to provide ",
        "type": "array",
        "minItems": 1,
        "maxItems": 1000,
        "uniqueItems": true,
        "items" : {
          "$ref" : "#"
        }
      }
    }
  }
#+END_SRC

**** XML

#+BEGIN_SRC xml :tangle ../rsrc-schema/src/vnd.eci.stg.probe.1.5.0.xsd
    <?xml version='1.0' encoding='utf-8'?>

    <xs:schema xmlns:xs='http://www.w3.org/2001/XMLSchema'
               elementFormDefault='qualified'
               xml:lang='en'>

      <xs:element name='item' type='itemType' />

      <xs:complexType name='itemType'>
        <xs:sequence>
          <xs:annotation>
            <xs:documentation>
              TODO
            </xs:documentation>
          </xs:annotation>
          <xs:element name='code'        type='xs:string'   minOccurs='0' maxOccurs='1' />
          <xs:element name='name'        type='xs:string'   minOccurs='0' maxOccurs='1' />
          <xs:element name='description' type='xs:string'   minOccurs='0' maxOccurs='1' />
          <xs:element name='remarks'     type='xs:string'   minOccurs='0' maxOccurs='1' />
          <xs:element name='self'        type='xs:string'   minOccurs='0' maxOccurs='1' />
          <xs:element name='status'      type='xs:string'   minOccurs='0' maxOccurs='1' />
          <xs:element name='when'        type='xs:dateTime' minOccurs='0' maxOccurs='1' />
          <xs:element name='itemCount'   type='xs:integer' minOccurs='0' maxOccurs='1' />
          <xs:element name='items' minOccurs='0' maxOccurs='1'>
            <xs:complexType>
              <xs:sequence minOccurs='1' maxOccurs='500'>
                <xs:element name='item' type='itemType'/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:complexType>
    </xs:schema>

#+END_SRC
*** Version 2.0

#+BEGIN_QUOTE
TBD
#+END_QUOTE

** © 2018 ECi Software Solutions, Inc. All rights reserved.
